# Generated by Django 6.0.1 on 2026-01-19 22:25

from django.db import migrations
from cryptography.fernet import Fernet, InvalidToken


def migrate_entries_to_per_user_encryption(apps, schema_editor):
    """
    Re-encrypt existing entries with per-user keys.

    1. Decrypt content using global key (EncryptedTextField format)
    2. Re-encrypt using user's personal key
    3. Set key_version
    """
    Entry = apps.get_model('journal', 'Entry')
    EncryptionKey = apps.get_model('accounts', 'EncryptionKey')

    from django.conf import settings

    global_key = getattr(settings, 'FIELD_ENCRYPTION_KEY', None)
    if not global_key:
        print("No FIELD_ENCRYPTION_KEY found, skipping entry migration")
        return

    if isinstance(global_key, str):
        global_key = global_key.encode('utf-8')

    global_fernet = Fernet(global_key)
    master_fernet = Fernet(global_key)  # For decrypting user keys

    migrated = 0
    skipped = 0

    for entry in Entry.objects.select_related('user').all():
        if not entry.content:
            skipped += 1
            continue

        # Skip if already has key_version (already migrated)
        if entry.key_version:
            skipped += 1
            continue

        # Get user's encryption key
        user_key = EncryptionKey.objects.filter(user=entry.user).first()
        if not user_key:
            raise RuntimeError(
                f"No encryption key found for user {entry.user_id} (entry {entry.id}). "
                f"Please run migration 0010_create_encryption_keys_for_existing_users first."
            )

        # Try to decrypt with global key (old EncryptedTextField encryption)
        try:
            plaintext = global_fernet.decrypt(entry.content.encode('utf-8')).decode('utf-8')
        except InvalidToken:
            raise RuntimeError(
                f"Failed to decrypt entry {entry.id} for user {entry.user_id} with global key. "
                f"Content may be corrupted or already re-encrypted."
            )

        # Re-encrypt with user's key
        user_raw_key = master_fernet.decrypt(user_key.key.encode('utf-8'))
        user_fernet = Fernet(user_raw_key)
        new_content = user_fernet.encrypt(plaintext.encode('utf-8')).decode('utf-8')

        entry.content = new_content
        entry.key_version = user_key.version
        entry.save(update_fields=['content', 'key_version'])
        migrated += 1

    print(f"Migration complete: {migrated} migrated, {skipped} skipped")


def reverse_migration(apps, schema_editor):
    """
    Reverse migration - would need to re-encrypt with global key.
    This is complex and data-lossy, so we just warn.
    """
    print("Warning: Reverse migration not fully implemented. Manual intervention needed.")


class Migration(migrations.Migration):

    dependencies = [
        ('journal', '0007_add_key_version_to_entry'),
        ('accounts', '0010_create_encryption_keys_for_existing_users'),
    ]

    operations = [
        migrations.RunPython(
            migrate_entries_to_per_user_encryption,
            reverse_migration,
        ),
    ]
